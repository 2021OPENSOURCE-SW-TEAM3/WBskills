{"version":3,"file":"web-dialog.js","sources":["../node_modules/@a11y/focus-trap/focusable.js","../node_modules/@a11y/focus-trap/debounce.js","../node_modules/@a11y/focus-trap/focus-trap.js","../node_modules/@a11y/focus-trap/shadow.js","../node_modules/web-dialog/util.js","../node_modules/web-dialog/web-dialog.js","../node_modules/web-dialog/open-dialog.js"],"sourcesContent":["/**\n * Returns whether the element is hidden.\n * @param $elem\n */\nexport function isHidden($elem) {\n    return $elem.hasAttribute(\"hidden\")\n        || ($elem.hasAttribute(\"aria-hidden\") && $elem.getAttribute(\"aria-hidden\") !== \"false\")\n        // A quick and dirty way to check whether the element is hidden.\n        // For a more fine-grained check we could use \"window.getComputedStyle\" but we don't because of bad performance.\n        // If the element has visibility set to \"hidden\" or \"collapse\", display set to \"none\" or opacity set to \"0\" through CSS\n        // we won't be able to catch it here. We accept it due to the huge performance benefits.\n        || $elem.style.display === `none`\n        || $elem.style.opacity === `0`\n        || $elem.style.visibility === `hidden`\n        || $elem.style.visibility === `collapse`;\n    // If offsetParent is null we can assume that the element is hidden\n    // https://stackoverflow.com/questions/306305/what-would-make-offsetparent-null\n    //|| $elem.offsetParent == null;\n}\n/**\n * Returns whether the element is disabled.\n * @param $elem\n */\nexport function isDisabled($elem) {\n    return $elem.hasAttribute(\"disabled\")\n        || ($elem.hasAttribute(\"aria-disabled\") && $elem.getAttribute(\"aria-disabled\") !== \"false\");\n}\n/**\n * Determines whether an element is focusable.\n * Read more here: https://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus/1600194#1600194\n * Or here: https://stackoverflow.com/questions/18261595/how-to-check-if-a-dom-element-is-focusable\n * @param $elem\n */\nexport function isFocusable($elem) {\n    // Discard elements that are removed from the tab order.\n    if ($elem.getAttribute(\"tabindex\") === \"-1\" || isHidden($elem) || isDisabled($elem)) {\n        return false;\n    }\n    return (\n    // At this point we know that the element can have focus (eg. won't be -1) if the tabindex attribute exists\n    $elem.hasAttribute(\"tabindex\")\n        // Anchor tags or area tags with a href set\n        || ($elem instanceof HTMLAnchorElement || $elem instanceof HTMLAreaElement) && $elem.hasAttribute(\"href\")\n        // Form elements which are not disabled\n        || ($elem instanceof HTMLButtonElement\n            || $elem instanceof HTMLInputElement\n            || $elem instanceof HTMLTextAreaElement\n            || $elem instanceof HTMLSelectElement)\n        // IFrames\n        || $elem instanceof HTMLIFrameElement);\n}\n//# sourceMappingURL=focusable.js.map","const timeouts = new Map();\n/**\n * Debounces a callback.\n * @param cb\n * @param ms\n * @param id\n */\nexport function debounce(cb, ms, id) {\n    // Clear current timeout for id\n    const timeout = timeouts.get(id);\n    if (timeout != null) {\n        window.clearTimeout(timeout);\n    }\n    // Set new timeout\n    timeouts.set(id, window.setTimeout(() => {\n        cb();\n        timeouts.delete(id);\n    }, ms));\n}\n//# sourceMappingURL=debounce.js.map","import { debounce } from \"./debounce\";\nimport { isFocusable, isHidden } from \"./focusable\";\nimport { queryShadowRoot } from \"./shadow\";\n/**\n * Template for the focus trap.\n */\nconst template = document.createElement(\"template\");\ntemplate.innerHTML = `\n\t<div id=\"start\"></div>\n\t<div id=\"backup\"></div>\n\t<slot></slot>\n\t<div id=\"end\"></div>\n`;\n/**\n * Focus trap web component.\n * @customElement focus-trap\n * @slot - Default content.\n */\nexport class FocusTrap extends HTMLElement {\n    /**\n     * Attaches the shadow root.\n     */\n    constructor() {\n        super();\n        // The debounce id is used to distinguish this focus trap from others when debouncing\n        this.debounceId = Math.random().toString();\n        this._focused = false;\n        const shadow = this.attachShadow({ mode: \"open\" });\n        shadow.appendChild(template.content.cloneNode(true));\n        this.$backup = shadow.querySelector(\"#backup\");\n        this.$start = shadow.querySelector(\"#start\");\n        this.$end = shadow.querySelector(\"#end\");\n        this.focusLastElement = this.focusLastElement.bind(this);\n        this.focusFirstElement = this.focusFirstElement.bind(this);\n        this.onFocusIn = this.onFocusIn.bind(this);\n        this.onFocusOut = this.onFocusOut.bind(this);\n    }\n    // Whenever one of these attributes changes we need to render the template again.\n    static get observedAttributes() {\n        return [\n            \"inactive\"\n        ];\n    }\n    /**\n     * Determines whether the focus trap is active or not.\n     * @attr\n     */\n    get inactive() {\n        return this.hasAttribute(\"inactive\");\n    }\n    set inactive(value) {\n        value ? this.setAttribute(\"inactive\", \"\") : this.removeAttribute(\"inactive\");\n    }\n    /**\n     * Returns whether the element currently has focus.\n     */\n    get focused() {\n        return this._focused;\n    }\n    /**\n     * Hooks up the element.\n     */\n    connectedCallback() {\n        this.$start.addEventListener(\"focus\", this.focusLastElement);\n        this.$end.addEventListener(\"focus\", this.focusFirstElement);\n        // Focus out is called every time the user tabs around inside the element\n        this.addEventListener(\"focusin\", this.onFocusIn);\n        this.addEventListener(\"focusout\", this.onFocusOut);\n        this.render();\n    }\n    /**\n     * Tears down the element.\n     */\n    disconnectedCallback() {\n        this.$start.removeEventListener(\"focus\", this.focusLastElement);\n        this.$end.removeEventListener(\"focus\", this.focusFirstElement);\n        this.removeEventListener(\"focusin\", this.onFocusIn);\n        this.removeEventListener(\"focusout\", this.onFocusOut);\n    }\n    /**\n     * When the attributes changes we need to re-render the template.\n     */\n    attributeChangedCallback() {\n        this.render();\n    }\n    /**\n     * Focuses the first focusable element in the focus trap.\n     */\n    focusFirstElement() {\n        this.trapFocus();\n    }\n    /**\n     * Focuses the last focusable element in the focus trap.\n     */\n    focusLastElement() {\n        this.trapFocus(true);\n    }\n    /**\n     * Returns a list of the focusable children found within the element.\n     */\n    getFocusableElements() {\n        return queryShadowRoot(this, isHidden, isFocusable);\n    }\n    /**\n     * Focuses on either the last or first focusable element.\n     * @param {boolean} trapToEnd\n     */\n    trapFocus(trapToEnd) {\n        if (this.inactive)\n            return;\n        let focusableChildren = this.getFocusableElements();\n        if (focusableChildren.length > 0) {\n            if (trapToEnd) {\n                focusableChildren[focusableChildren.length - 1].focus();\n            }\n            else {\n                focusableChildren[0].focus();\n            }\n            this.$backup.setAttribute(\"tabindex\", \"-1\");\n        }\n        else {\n            // If there are no focusable children we need to focus on the backup\n            // to trap the focus. This is a useful behavior if the focus trap is\n            // for example used in a dialog and we don't want the user to tab\n            // outside the dialog even though there are no focusable children\n            // in the dialog.\n            this.$backup.setAttribute(\"tabindex\", \"0\");\n            this.$backup.focus();\n        }\n    }\n    /**\n     * When the element gains focus this function is called.\n     */\n    onFocusIn() {\n        this.updateFocused(true);\n    }\n    /**\n     * When the element looses its focus this function is called.\n     */\n    onFocusOut() {\n        this.updateFocused(false);\n    }\n    /**\n     * Updates the focused property and updates the view.\n     * The update is debounced because the focusin and focusout out\n     * might fire multiple times in a row. We only want to render\n     * the element once, therefore waiting until the focus is \"stable\".\n     * @param value\n     */\n    updateFocused(value) {\n        debounce(() => {\n            if (this.focused !== value) {\n                this._focused = value;\n                this.render();\n            }\n        }, 0, this.debounceId);\n    }\n    /**\n     * Updates the template.\n     */\n    render() {\n        this.$start.setAttribute(\"tabindex\", !this.focused || this.inactive ? `-1` : `0`);\n        this.$end.setAttribute(\"tabindex\", !this.focused || this.inactive ? `-1` : `0`);\n        this.focused ? this.setAttribute(\"focused\", \"\") : this.removeAttribute(\"focused\");\n    }\n}\nwindow.customElements.define(\"focus-trap\", FocusTrap);\n//# sourceMappingURL=focus-trap.js.map","/**\n * Traverses the slots of the open shadowroots and returns all children matching the query.\n * @param {ShadowRoot | HTMLElement} root\n * @param skipNode\n * @param isMatch\n * @param {number} maxDepth\n * @param {number} depth\n * @returns {HTMLElement[]}\n */\nexport function queryShadowRoot(root, skipNode, isMatch, maxDepth = 20, depth = 0) {\n    let matches = [];\n    // If the depth is above the max depth, abort the searching here.\n    if (depth >= maxDepth) {\n        return matches;\n    }\n    // Traverses a slot element\n    const traverseSlot = ($slot) => {\n        // Only check nodes that are of the type Node.ELEMENT_NODE\n        // Read more here https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n        const assignedNodes = $slot.assignedNodes().filter(node => node.nodeType === 1);\n        if (assignedNodes.length > 0) {\n            return queryShadowRoot(assignedNodes[0].parentElement, skipNode, isMatch, maxDepth, depth + 1);\n        }\n        return [];\n    };\n    // Go through each child and continue the traversing if necessary\n    // Even though the typing says that children can't be undefined, Edge 15 sometimes gives an undefined value.\n    // Therefore we fallback to an empty array if it is undefined.\n    const children = Array.from(root.children || []);\n    for (const $child of children) {\n        // Check if the node and its descendants should be skipped\n        if (skipNode($child)) {\n            continue;\n        }\n        // If the child matches we always add it\n        if (isMatch($child)) {\n            matches.push($child);\n        }\n        if ($child.shadowRoot != null) {\n            matches.push(...queryShadowRoot($child.shadowRoot, skipNode, isMatch, maxDepth, depth + 1));\n        }\n        else if ($child.tagName === \"SLOT\") {\n            matches.push(...traverseSlot($child));\n        }\n        else {\n            matches.push(...queryShadowRoot($child, skipNode, isMatch, maxDepth, depth + 1));\n        }\n    }\n    return matches;\n}\n//# sourceMappingURL=shadow.js.map","/**\n * Returns the data dialog count for an element.\n * @param $elem\n */\nfunction getDialogCount($elem) {\n    return Number($elem.getAttribute(`data-dialog-count`)) || 0;\n}\n/**\n * Sets the data dialog count for an element.\n * @param $elem\n * @param count\n */\nfunction setDialogCount($elem, count) {\n    $elem.setAttribute(`data-dialog-count`, count.toString());\n}\n/**\n * Traverses the tree of active elements down the shadow tree.\n * @param activeElement\n */\nfunction traverseActiveElements(activeElement = document.activeElement) {\n    if (activeElement != null && activeElement.shadowRoot != null && activeElement.shadowRoot.activeElement != null) {\n        return traverseActiveElements(activeElement.shadowRoot.activeElement);\n    }\n    return activeElement;\n}\n\nexport { getDialogCount, setDialogCount, traverseActiveElements };\n","import '@a11y/focus-trap';\nimport { traverseActiveElements, setDialogCount, getDialogCount } from './util.js';\n\nvar styles = `*{box-sizing:border-box}:host{padding:var(--dialog-container-padding,5vw 24px);z-index:var(--dialog-z-index,12345678);outline:none}#backdrop,:host{position:fixed;top:0;left:0;bottom:0;right:0}:host,:host([center]) #dialog{overflow-x:var(--dialog-overflow-x,hidden);overflow-y:var(--dialog-overflow-y,auto);overscroll-behavior:contain;-webkit-overflow-scrolling:touch}:host([center]){display:flex;align-items:center;justify-content:center;overflow:hidden}:host([center]) #dialog{max-height:var(--dialog-max-height,100%)}:host(:not(:defined)),:host(:not([open])){display:none}#backdrop{background:var(--dialog-backdrop-bg,rgba(0,0,0,.6));animation:fadeIn var(--dialog-animation-duration,.1s) var(--dialog-animation-easing,ease-out);z-index:-1}#dialog{animation:scaleIn var(--dialog-animation-duration,.1s) var(--dialog-animation-easing,ease-out);border-radius:var(--dialog-border-radius,12px);box-shadow:var(--dialog-box-shadow,0 2px 10px -5px rgba(0,0,0,.6));max-width:var(--dialog-max-width,700px);width:var(--dialog-width,100%);padding:var(--dialog-padding,24px);max-height:var(--dialog-max-height,unset);height:var(--dialog-height,auto);color:var(--dialog-color,currentColor);background:var(--dialog-bg,#fff);z-index:1;position:relative;display:flex;flex-direction:column;margin:0 auto;border:none}::slotted(article),article{flex-grow:1;overflow-y:auto;-webkit-overflow-scrolling:touch}::slotted(footer),::slotted(header),footer,header{flex-shrink:0}@keyframes scaleIn{0%{transform:scale(.9) translateY(30px);opacity:0}to{transform:scale(1) translateY(0);opacity:1}}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}`;\n\nconst template = document.createElement(\"template\");\ntemplate.innerHTML = `\n  <style>${styles}</style>\n  <div id=\"backdrop\" part=\"backdrop\"></div>\n  <focus-trap id=\"dialog\" part=\"dialog\">\n    <slot></slot>\n  </focus-trap>\n`;\n/**\n * A dialog web component that can be used to display highly interruptive messages.\n * @fires open - This event is fired when the dialog opens.\n * @fires close - This event is fired when the dialog closes.\n * @fires closing - This event is fired before the dialog is closed by clicking escape or on the backdrop. The event is cancellable which means `event.preventDefault()` can cancel the closing of the dialog.\n * @cssprop --dialog-container-padding - Padding of the host container of the dialog.\n * @cssprop --dialog-z-index - Z-index of the dialog.\n * @cssprop --dialog-overflow-x - Overflow of the x-axis.\n * @cssprop --dialog-overflow-y - Overflow of the y-axis.\n * @cssprop --dialog-max-height - Max height of the dialog.\n * @cssprop --dialog-height - Height of the dialog.\n * @cssprop --dialog-backdrop-bg - Background of the backdrop.\n * @cssprop --dialog-animation-duration - Duration of the dialog animation.\n * @cssprop --dialog-animation-easing - Easing of the dialog animation.\n * @cssprop --dialog-border-radius - Border radius of the dialog.\n * @cssprop --dialog-box-shadow - Box shadow of the dialog.\n * @cssprop --dialog-max-width - Max width of the dialog.\n * @cssprop --dialog-width - Width of the dialog.\n * @cssprop --dialog-padding - Padding of the dialog.\n * @cssprop --dialog-color - Color of the dialog.\n * @cssprop --dialog-bg - Background of the dialog.\n * @csspart backdrop - Backdrop part.\n * @csspart dialog - Dialog part.\n */\nclass WebDialog extends HTMLElement {\n    /**\n     * Attaches the shadow root.\n     */\n    constructor() {\n        super();\n        this.$scrollContainer = document.documentElement;\n        this.$previousActiveElement = null;\n        const shadow = this.attachShadow({ mode: \"open\" });\n        shadow.appendChild(template.content.cloneNode(true));\n        this.$dialog = shadow.querySelector(\"#dialog\");\n        this.$backdrop = shadow.querySelector(\"#backdrop\");\n        this.onBackdropClick = this.onBackdropClick.bind(this);\n        this.onKeyDown = this.onKeyDown.bind(this);\n        // Set aria attributes\n        this.setAttribute(\"aria-modal\", \"true\");\n        this.$dialog.setAttribute(\"role\", \"alertdialog\");\n    }\n    static get observedAttributes() {\n        return [\"open\", \"center\"];\n    }\n    /**\n     * Whether the dialog is opened.\n     * @attr\n     */\n    get open() {\n        return this.hasAttribute(\"open\");\n    }\n    set open(value) {\n        value ? this.setAttribute(\"open\", \"\") : this.removeAttribute(\"open\");\n    }\n    /**\n     * Whether the dialog is centered on the page.\n     * @attr\n     */\n    get center() {\n        return this.hasAttribute(\"center\");\n    }\n    set center(value) {\n        value ? this.setAttribute(\"center\", \"\") : this.removeAttribute(\"center\");\n    }\n    /**\n     * Attaches event listeners when connected.\n     */\n    connectedCallback() {\n        this.$backdrop.addEventListener(\"click\", this.onBackdropClick);\n    }\n    /**\n     * Removes event listeners when disconnected.\n     */\n    disconnectedCallback() {\n        this.$backdrop.removeEventListener(\"click\", this.onBackdropClick);\n        // If the dialog is open when it is removed from the DOM\n        // we need to cleanup the event listeners and side effects.\n        if (this.open) {\n            this.didClose();\n        }\n    }\n    /**\n     * Shows the dialog.\n     */\n    show() {\n        this.open = true;\n    }\n    /**\n     * Closes the dialog with a result.\n     * @param result\n     */\n    close(result) {\n        this.result = result;\n        this.open = false;\n    }\n    /**\n     * Closes the dialog when the backdrop is clicked.\n     */\n    onBackdropClick() {\n        if (this.assertClosing()) {\n            this.close();\n        }\n    }\n    /**\n     * Closes the dialog when escape is pressed.\n     */\n    onKeyDown(e) {\n        switch (e.code) {\n            case \"Escape\":\n                if (this.assertClosing()) {\n                    this.close();\n                    // If there are more dialogs, we don't want to close those also :-)\n                    e.stopImmediatePropagation();\n                }\n                break;\n        }\n    }\n    /**\n     * Dispatches an event that, if asserts whether the dialog can be closed.\n     * If \"preventDefault()\" is called on the event, assertClosing will return true\n     * if the event was not cancelled. It will return false if the event was cancelled.\n     */\n    assertClosing() {\n        return this.dispatchEvent(new CustomEvent(\"closing\", { cancelable: true }));\n    }\n    /**\n     * Setup the dialog after it has opened.\n     */\n    didOpen() {\n        // Save the current active element so we have a way of restoring the focus when the dialog is closed.\n        this.$previousActiveElement = traverseActiveElements(document.activeElement);\n        // Focus the first element in the focus trap.\n        // Wait for the dialog to show its content before we try to focus inside it.\n        // We request an animation frame to make sure the content is now visible.\n        requestAnimationFrame(() => {\n            this.$dialog.focusFirstElement();\n        });\n        // Make the dialog focusable\n        this.tabIndex = 0;\n        // Block the scrolling on the scroll container to avoid the outside content to scroll.\n        this.$scrollContainer.style.overflow = `hidden`;\n        // Listen for key down events to close the dialog when escape is pressed.\n        this.addEventListener(\"keydown\", this.onKeyDown, { capture: true, passive: true });\n        // Increment the dialog count with one to keep track of how many dialogs are currently nested.\n        setDialogCount(this.$scrollContainer, getDialogCount(this.$scrollContainer) + 1);\n        // Dispatch an event so the rest of the world knows the dialog opened.\n        this.dispatchEvent(new CustomEvent(\"open\"));\n    }\n    /**\n     * Clean up the dialog after it has closed.\n     */\n    didClose() {\n        // Remove the listener listening for key events\n        this.removeEventListener(\"keydown\", this.onKeyDown, { capture: true });\n        // Decrement the dialog count with one to keep track of how many dialogs are currently nested.\n        setDialogCount(this.$scrollContainer, Math.max(0, getDialogCount(this.$scrollContainer) - 1));\n        // If there are now 0 active dialogs we unblock the scrolling from the scroll container.\n        // This is because we know that no other dialogs are currently nested within the scroll container.\n        if (getDialogCount(this.$scrollContainer) <= 0) {\n            this.$scrollContainer.style.overflow = ``;\n        }\n        // Make the dialog unfocusable.\n        this.tabIndex = -1;\n        // Restore previous active element.\n        if (this.$previousActiveElement != null) {\n            this.$previousActiveElement.focus();\n            this.$previousActiveElement = null;\n        }\n        // Dispatch an event so the rest of the world knows the dialog closed.\n        // If a result has been set, the result is added to the detail property of the event.\n        this.dispatchEvent(new CustomEvent(\"close\", { detail: this.result }));\n    }\n    /**\n     * Reacts when an observed attribute changes.\n     */\n    attributeChangedCallback(name, newValue, oldValue) {\n        switch (name) {\n            case \"open\":\n                this.open ? this.didOpen() : this.didClose();\n                break;\n        }\n    }\n}\ncustomElements.define(\"web-dialog\", WebDialog);\n\nexport { WebDialog };\n","import '@a11y/focus-trap';\nimport { WebDialog } from './web-dialog.js';\nimport './util.js';\n\n/**\n * Opens a dialog and appends it to the container.\n * @param $content\n * @param $container\n * @param center\n * @param initialize\n */\nfunction openDialog({ $content, $container = document.body, center = false, initialize = (() => new WebDialog()) } = {}) {\n    // Construct the dialog.\n    const $dialog = initialize();\n    // Set the relevant properties of the dialog.\n    if (center != null) {\n        $dialog.center = center;\n    }\n    // Attach the content to the dialog.\n    if ($content != null) {\n        if (typeof $content === \"function\") {\n            $content($dialog);\n        }\n        else {\n            $dialog.appendChild($content);\n        }\n    }\n    // Create a resolver that resolves when the dialog closes.\n    const resolver = new Promise(res => {\n        $dialog.addEventListener(\"close\", (e) => {\n            $dialog.remove();\n            res(e.detail);\n        }, { once: true });\n    });\n    // Append the dialog to the container and open it.\n    $container.appendChild($dialog);\n    $dialog.show();\n    return { $dialog, resolver };\n}\n\nexport { openDialog };\n"],"names":["isHidden","$elem","hasAttribute","getAttribute","style","display","opacity","visibility","isFocusable","isDisabled","HTMLAnchorElement","HTMLAreaElement","HTMLButtonElement","HTMLInputElement","HTMLTextAreaElement","HTMLSelectElement","HTMLIFrameElement","timeouts","Map","template","document","createElement","innerHTML","FocusTrap","HTMLElement","[object Object]","debounceId","Math","random","toString","_focused","shadow","this","attachShadow","mode","appendChild","content","cloneNode","$backup","querySelector","$start","$end","focusLastElement","bind","focusFirstElement","onFocusIn","onFocusOut","value","setAttribute","removeAttribute","addEventListener","render","removeEventListener","trapFocus","queryShadowRoot","root","skipNode","isMatch","maxDepth","depth","matches","traverseSlot","$slot","assignedNodes","filter","node","nodeType","length","parentElement","children","Array","from","$child","push","shadowRoot","tagName","trapToEnd","inactive","focusableChildren","getFocusableElements","focus","updateFocused","cb","ms","id","timeout","get","window","clearTimeout","set","setTimeout","delete","debounce","focused","getDialogCount","Number","setDialogCount","count","traverseActiveElements","activeElement","customElements","define","WebDialog","constructor","$scrollContainer","documentElement","$previousActiveElement","$dialog","$backdrop","onBackdropClick","onKeyDown","connectedCallback","disconnectedCallback","open","didClose","show","close","result","assertClosing","e","code","stopImmediatePropagation","dispatchEvent","CustomEvent","cancelable","didOpen","requestAnimationFrame","tabIndex","overflow","capture","passive","max","detail","attributeChangedCallback","name","newValue","oldValue","openDialog","$content","$container","body","center","initialize","resolver","Promise","res","remove","once"],"mappings":"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"}